#!/usr/bin/env node
/*
  Generate src/utils/index.ts by exporting all .ts/.tsx files under src/utils
  Usage: node scripts/generate-utils-index.cjs
*/
const fs = require('fs');
const path = require('path');

const projectRoot = process.cwd();
const utilsDir = path.join(projectRoot, 'src', 'utils');
const indexFile = path.join(utilsDir, 'index.ts');

function ensureDir(p) {
  if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
}

function walk(dir) {
  const out = [];
  if (!fs.existsSync(dir)) return out;
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const full = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      out.push(...walk(full));
    } else if (entry.isFile()) {
      out.push(full);
    }
  }
  return out;
}

function toModulePath(absFile) {
  // Convert absolute file path under utilsDir to TS import path starting './'
  const rel = path.relative(utilsDir, absFile);
  const noExt = rel.replace(/\.(tsx?|cts|mts)$/i, '');
  const parts = noExt.split(path.sep).filter(Boolean);
  // Use posix separators for module specifiers
  return './' + parts.join('/');
}

function isExportable(file) {
  const base = path.basename(file);
  if (/^index\.(d\.ts|ts|tsx|mts|cts)$/i.test(base)) return false; // skip index
  if (/\.(test|spec)\.(ts|tsx|mts|cts)$/i.test(base)) return false; // skip tests
  if (/\.d\.ts$/i.test(base)) return false; // skip type decls
  return /\.(ts|tsx|mts|cts)$/i.test(base);
}

function main() {
  ensureDir(utilsDir);
  const files = walk(utilsDir).filter(isExportable);
  files.sort((a, b) => a.localeCompare(b));
  const modulePaths = files.map(toModulePath);

  const header = '// AUTO-GENERATED by scripts/generate-utils-index.cjs\n';
  const body = modulePaths
    .map((m) => `export * from '${m}';`)
    .join('\n');
  const content = header + (body ? body + '\n' : '// no utils found\n');

  fs.writeFileSync(indexFile, content, 'utf8');
  console.log(`Wrote ${indexFile} with ${modulePaths.length} exports.`);
}

main();

